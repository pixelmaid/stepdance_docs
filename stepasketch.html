<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stepdance Software Library: Step-A-Sketch Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Stepdance Software Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('stepasketch.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Step-A-Sketch Example </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Overview</h2>
<p><img src="step-a-sketch_teaser.png" alt="" class="inline"/>    </p>
<p>This example uses two encoders to control a pen plotter (e.g. an AxiDraw) in realtime, a la etch-a-sketch. One knob is mapped to the X axis, and the other to the Y axis. You will learn how to:</p>
<ul>
<li>configure outputs ports, in this case to control stepper motor drivers</li>
<li>create "channels" that each generate output stream components for individual axes of motion.</li>
<li>use kinematic modules to convert between cartesian XY space and machine motor space.</li>
<li>read position values from encoders, and use them to drive output channels.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Configuring the Stepdance Driver Board</h2>
<p>The axidraw has two stepper motors for XY positioning and a single servo motor for the pen height. The AxiDraw Inkscape plugin <em>and</em> the Stepdance AxiDraw software module both expect that the motors are 200 steps/rev and driven at 1/16th microstepping. You'll want to configure the Stepdance Driver Board as follows:</p>
<ul>
<li>To set 1/16 microstepping, install jumpers on both microstepping headers for the A and B output ports as shown below. The jumpers should be oriented vertically (see the Stepper Drivers and Motor Interfaces section on the main page).</li>
<li>Install two TMC2209 stepper drivers and one <a href="../readme.md#hobby-servo-driver">Hobby Servo Driver</a> as shown below.</li>
</ul>
<div class="image">
<img src="step-a-sketch_board.png" alt=""/>
</div>
    <h2 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Wiring</h2>
<p><img src="step-a-sketch_wiring.png" alt="" class="inline"/>    </p>
<p>There are eight wiring connections to be made:</p>
<ul>
<li>Both AxiDraw stepper motors to Output Ports A and B. We've wired the left motor to A, and the right motor to B.</li>
<li>The servo motor to Output Port C.</li>
<li>Two encoders, one to each of the encoder input ports ENC1 and ENC2. <a class="el" href="taiss.html">Details on wiring Taiss encoders are here</a>. Refer to the board reference on the main page for general info on wiring encoders.</li>
<li>One pushbutton to digital input port D1.</li>
<li>5VDC to the Teensy 4.1, delivered over a micro-usb cable. This powers the logic for all of the electronics, except for the hobby servo driver, which generates its own 5V supply. Initially, power this via your computer while programming the Teensy with firmware. Then, you can provide power from a USB charger etc.</li>
<li>12VDC to the 5.5mm OD / 2.1mm ID barrel plug.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Wiring Stepper Motors</h3>
<p><img src="stepper_wiring.png" alt="" class="inline"/>    </p>
<p>The Stepdance driver board supports <em>two phase</em> stepper motors. These phases "A" and "B" (represented by blue and red inductor symbols in the diagram above) each has two wires coming off the motor, for four leads total. In order for the motor to spin, it is essential that each phase's two wires enter the connector at adjacent pins.</p>
<p>Sometimes you can rely on the stepper motor mfg for the color code, but sometimes you can't, or you don't know the manufacturer. A simple test is to put a multimeter in ohmeter mode across any two of the four motor wires. If you read a low resistance (typically &lt; 20 ohms), these wires belong to the same phase and should be adjacent to each other on the connector. If you read an infinite resistance, try a different combination.</p>
<p>Flipping the two wires within a phase, or flipping the two phases, will change the direction that the motor spins; this can be corrected in software.</p>
<p>Below illustrates the color codes used in the AxiDraw V3.</p>
<div class="image">
<img src="axidraw_wiring.png" alt=""/>
</div>
    <h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Wiring the Servo Motor</h3>
<p><img src="servo_wiring.png" alt="" class="inline"/>    </p>
<p>Note that the servo is wired into the same 4-pin connector and header as the stepper motors.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Wiring the Button</h3>
<p><img src="button_wiring.png" alt="" class="inline"/>    </p>
<p>The button should be wired across the INPUT and 3V3 pins of the Molex SL connector, as shown. We will configure the Teensy to apply an internal pull-down resistor to the input pin, which will cause the input to read LOW when not pressed and HIGH when pressed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Setting the Motor Driver Currents</h3>
<p>Most modern stepper drivers, including the TMC2209s supported by the Stepdance Driver Board, operate using current control. This means that a high voltage (e.g. 24VDC) is used to quickly pump current into the motor coils, and is then cut off once a target current is reached. This allows much higher performance of the motor than a voltage-controlled driver, which needs to operate at a lower voltage in order to avoid over-heating the motor coils. The current control circuitry works by measuring current in each motor coil through a sensing resistor, thereby converting current to voltage, and then comparing this to a reference voltage that sets the current limit. Your mission is to set the reference voltage on each driver to correspond to the rated motor current.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Determine the Peak Motor Current</h4>
<p>Motors are typically rated in amps/phase, which is a root-mean-square (RMS) value. The current limits on drivers are typically set in peak current by adjusting a reference voltage. First, you should look up the current rating of whichever motors you are using. For an Axidraw V3, this is 1A/phase. Next, convert this value into peak current, by multiplying by 1.414. This is 1.4A for the Axidraw V3.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Calculate the Reference Voltage</h4>
<p>The BIGTREETECH TMC2209 drivers are configured with a gain of 1V/1A, so to calculate the reference voltage, you simply multiply the target peak current by 1.0. For the Axidraw V3, the reference voltage is 1.4V.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Set the Reference Voltage</h4>
<p><img src="ref_voltage.png" alt="" class="inline"/>    </p>
<p>Using a multimeter, measure the voltage between VREF and GND as shown in the image, and slowly turn the potentiometer until the reading matches your target voltage. A few important notes:</p>
<ul>
<li>To get an accurate reading, the Stepdance Driver Board MUST be powered with both +5V thru the USB port of the Teensy 4.1, AND motor power (e.g. 12V or 24V) thru the DC barrel jack. The BIGTREETECH drivers generate their own reference voltage from the motor power supply.</li>
<li>BE VERY CAREFUL when applying the multimeter probes to the VREF and GND pins on the driver. It is very easy to short out the power supply. If you want to play it safe, probe the GND signal at the Teensy 4.1 instead, using the exposed pads below the Teensy 4.1 socket.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Code</h2>
<p>The Step A Sketch code is in the example folder. In the sections below, we walk thru the code by section and explain how all the pieces fit together.</p>
<div class="image">
<img src="stepasketch_diagram.png" alt=""/>
</div>
    <h3 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Board Definition</h3>
<div class="fragment"><div class="line">#define module_driver</div>
</div><!-- fragment --><p>This tells the compiler which board we're using. The other option is <em>module_basic</em>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Includes</h3>
<div class="fragment"><div class="line">#include &quot;stepdance.hpp&quot;</div>
</div><!-- fragment --><p> Imports the entire stepdance library. <em>stepdance.hpp</em> includes all the relevant files.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Define all stepdance components</h3>
<div class="fragment"><div class="line">OutputPort output_a;  // Axidraw left motor</div>
<div class="line">OutputPort output_b;  // Axidraw right motor</div>
<div class="line">OutputPort output_c;  // Z axis, a servo driver for the AxiDraw</div>
<div class="line"> </div>
<div class="line">Channel channel_a;  //AxiDraw &quot;A&quot; axis --&gt; left motor motion</div>
<div class="line">Channel channel_b;  // AxiDraw &quot;B&quot; axis --&gt; right motor motion</div>
<div class="line">Channel channel_z;  // AxiDraw &quot;Z&quot; axis --&gt; pen up/down</div>
<div class="line"> </div>
<div class="line">KinematicsCoreXY axidraw_kinematics;</div>
<div class="line"> </div>
<div class="line">Encoder encoder_1;  // left knob, controls horizontal</div>
<div class="line">Encoder encoder_2;  // right knob, controls vertical</div>
<div class="line"> </div>
<div class="line">Button button_d1;   // pen up/down button</div>
<div class="line"> </div>
<div class="line">PositionGenerator position_gen; //pen up/down motion generator</div>
</div><!-- fragment --><p>Here we instantiate objects for all the stepdance components we'll be using.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
OutputPort</h4>
<p>This software module is responsible for converting a internal step commands into a frame of pulse signals on a stepdance output port.</p>
<p>For this example, these output ports are being used to individually control three motor drivers: two stepper drivers for XY motion and a hobby servo controller that emulates a stepper driver. Consequently, we define one output port for each of the motor drivers.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Channel</h4>
<p>Channels are software modules that generate internal step commands, and route them to output ports; they do so by tracking a target position while applying velocity limits. Typically, one channel is used for each motion axis of a machine. Channels are also where the positional state of each axis is usually stored.</p>
<p>We define a channel for the "A" and "B" motors of the Axidraw, as well as the "Z" axis pen control.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
KinematicsCoreXY</h4>
<p>There are many mechanical kinematics used to drive machines, but conceptually, most machines operate either in XYZ (i.e. Cartesian) or RÎ¸ (i.e. polar) space. To support these various mechanical arrangements, Stepdance has kinematics modules that convert from "normal" cartesian or polar space into motor angle space.</p>
<p>The AxiDraw uses a belt-driven positioning mechanism with differential kinematics, which is supported by the <a class="el" href="class_kinematics_core_x_y.html">KinematicsCoreXY</a> module.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Encoder</h4>
<p>This module supports using quadrature encoders as inputs for other stepdance modules.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Button</h4>
<p>This module reads a digital signal from one of the inputs (A1-&gt;A4, D1-&gt;D2) and calls functions based on how the signal changes and how the button is configured.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
PositionGenerator</h4>
<p>In order to lift and lower the pen, we instantiate a position generator, which will drive a distance at a set velocity.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Setup()</h3>
<p>The setup function is the standard Arduino function that is called once before loop() gets called continuously.</p>
<p>Note that with the exception of <a class="el" href="class_input_port.html" title="InputPort components receive motion streams on physical Stepdance input ports, and map these signals ...">InputPort</a>, <a class="el" href="class_output_port.html" title="OutputPorts are modules that convert internal step commands into a frame of pulse signals on the phys...">OutputPort</a>, and <a class="el" href="class_channel.html" title="Channels are modules that store the machine&#39;s positional state.">Channel</a>, all other software modules must be started by calling begin() in the order that they should run. For example, in the code below, we will start the encoders before we start the kinematics, because the encoders feed into the kinematics and therefore must run first.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Enable the Stepper Motors</h4>
<div class="fragment"><div class="line">pinMode(14, OUTPUT); //motor A enable</div>
<div class="line">pinMode(13, OUTPUT); //motor B enable</div>
<div class="line">digitalWrite(14, LOW); //enable motors</div>
<div class="line">digitalWrite(13, LOW);</div>
</div><!-- fragment --><p>Eventually this will be handled automatically, but for now, we do it manually.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Configure Output Ports</h4>
<div class="fragment"><div class="line">output_a.begin(OUTPUT_A);</div>
<div class="line">output_b.begin(OUTPUT_B);</div>
<div class="line">output_c.begin(OUTPUT_C);</div>
</div><!-- fragment --><p>Each <a class="el" href="class_output_port.html" title="OutputPorts are modules that convert internal step commands into a frame of pulse signals on the phys...">OutputPort</a> module is begun with the name of the physical output port to which it is attached. Note that for clarity we name the <a class="el" href="class_output_port.html" title="OutputPorts are modules that convert internal step commands into a frame of pulse signals on the phys...">OutputPort</a> instances the same as the physical output port names.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Configure Channels</h4>
<div class="fragment"><div class="line">channel_a.begin(&amp;output_a, SIGNAL_E);</div>
<div class="line">channel_a.set_transmission_ratio(25.4, 2874);</div>
<div class="line">channel_a.invert_output();</div>
<div class="line"> </div>
<div class="line">channel_b.begin(&amp;output_b, SIGNAL_E);</div>
<div class="line">channel_b.set_transmission_ratio(25.4, 2874);</div>
<div class="line">channel_b.invert_output();</div>
<div class="line"> </div>
<div class="line">channel_z.begin(&amp;output_c, SIGNAL_E);</div>
<div class="line">channel_z.set_transmission_ratio(1, 1);</div>
</div><!-- fragment --><p>Each channel is begun with a pointer to the target <a class="el" href="class_output_port.html" title="OutputPorts are modules that convert internal step commands into a frame of pulse signals on the phys...">OutputPort</a> and the signal asserted on that output port when the channel takes a step. Because the output ports are directly connected to stepper drivers, we choose the longest pulse-width signal, "E", to make it compatible especially with our servo emulator.</p>
<p>Next, we set an input "transmission ratio" on each channel. This helps with converting between units. Most of the Stepdance modules will operate internally in linear units such as mm, while the channel itself operates in steps. So the set_transmission_ratio() function specifies how many input units (first parameter) equals how many output units (second parameter). In this case, 25.4mm (i.e. 1 inch) is equivalent to 2876 axidraw motor microsteps. Note that the Z axis servo motor will operate internally in steps rather than mm.</p>
<p>Finally, if needed, we can invert the output direction for any of the channels. You may need to play with these depending on how your motors are wired, to get the machine to move in the correct direction.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Configure Encoders</h4>
<div class="fragment"><div class="line">encoder_1.begin(ENCODER_1);</div>
<div class="line">encoder_1.set_ratio(2400, 24);</div>
<div class="line">encoder_1.map(&amp;axidraw_kinematics.input_transmission_x);</div>
<div class="line">encoder_1.invert(); //invert the encoder direction</div>
<div class="line"> </div>
<div class="line">encoder_2.begin(ENCODER_2);</div>
<div class="line">encoder_2.set_ratio(2400, 24);</div>
<div class="line">encoder_2.map(&amp;axidraw_kinematics.input_transmission_y);</div>
</div><!-- fragment --><p>Encoders are begun with the IO port name.</p>
<p>Next, we set an output ratio for the encoders; in this case, we say one revolution (2400 pulses for our TAISS encoders) is equivalent to 24mm.</p>
<p>We then connect the encoder to input transmissions of the kinematics module by calling the map() function. Note that the first encoder is mapped to "input_transmission_x" and the second encoder to "input_transmission_y". In this way, the first knob will move the axidraw in X, while the second knob will move it in Y.</p>
<p>Lastly, if necessary, we can invert the encoder directions.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Configure the Kinematics</h4>
<div class="fragment"><div class="line">axidraw_kinematics.begin();</div>
<div class="line">axidraw_kinematics.map(COREXY_OUTPUT_A, &amp;channel_a.target_position_transmission);</div>
<div class="line">axidraw_kinematics.map(COREXY_OUTPUT_B, &amp;channel_b.target_position_transmission);</div>
</div><!-- fragment --><p>Here we begin the kinematics module, and then map its outputs to the "A" and "B" motor channels.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Configure the Button</h4>
<div class="fragment"><div class="line">button_d1.begin(IO_D1, INPUT_PULLDOWN);</div>
<div class="line">button_d1.set_mode(BUTTON_MODE_TOGGLE);</div>
<div class="line">button_d1.set_callback_on_press(&amp;pen_down);</div>
<div class="line">button_d1.set_callback_on_release(&amp;pen_up);</div>
</div><!-- fragment --><p>First we initialize the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a> object by associating it with a physical input port (D1) and specify that the pin should have a pulldown using the standard Arduino definition.</p>
<p>Next, we configure the button as a toggle, meaning that the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a>'s logical state will change (e.g. from released to pressed, or vice-versa) when the input state changes. For example, physically pressing an attached button once may cause the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a> object to transition to a "pressed" state, and pressing the attached button a second time will then release the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a> object.</p>
<p>Lastly, we associate callback functions for when the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a> is pressed and released.</p>
<p>Importantly, depending on configuration, the <a class="el" href="class_button.html" title="Button class for handling digital input buttons.">Button</a> object's state (pressed, released) may not directly map to the state of the input physical button.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Configure Position Generator</h4>
<div class="fragment"><div class="line">position_gen.map(&amp;channel_z.target_position_transmission);</div>
<div class="line">position_gen.begin();</div>
</div><!-- fragment --><p>Here we directly connect the <a class="el" href="class_position_generator.html">PositionGenerator</a> object to the Z Axis <a class="el" href="class_channel.html" title="Channels are modules that store the machine&#39;s positional state.">Channel</a> object's input transmission.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Start Stepdance</h4>
<div class="fragment"><div class="line">dance_start();</div>
</div><!-- fragment --><p>Caling this function will start running all of the modules. This should be called last.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Loop()</h3>
<div class="fragment"><div class="line">void loop() {</div>
<div class="line">  dance_loop();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For this example, we actually don't need to do anything in the loop function! Stepdance largely runs in background interrupt routines. However, it is good practice to call dance_loop() at the end of the loop function, because it provides valuable utilities that you might want to use in your own code.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Custom Functions</h3>
<p>In order to implement pen up and pen down, we write two custom functions:</p>
<div class="fragment"><div class="line">void pen_down(){</div>
<div class="line">  position_gen.go_absolute(-500, 2000);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void pen_up(){</div>
<div class="line">  position_gen.go_absolute(500, 2000);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When called, these will cause the position generator to go to +500 or -500 steps, at a rate of 2000 steps/sec. This is the full range of the hobby servo driver board. Note that the absolute position state is stored in the <a class="el" href="class_position_generator.html">PositionGenerator</a> object, rather than in the Z Axis <a class="el" href="class_channel.html" title="Channels are modules that store the machine&#39;s positional state.">Channel</a> object. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
